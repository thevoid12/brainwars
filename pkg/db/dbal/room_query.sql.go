// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: room_query.sql

package dbal

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const creatLeaderBoard = `-- name: CreatLeaderBoard :exec
INSERT INTO leaderboard (
  id, 
  room_code,
  user_id, 
  score, 
  created_on, 
  updated_on, 
  created_by, 
  updated_by,
  is_deleted    
) 
VALUES ($1, $2, $3, $4, NOW(), NOW(), $5, $6,$7)
`

type CreatLeaderBoardParams struct {
	ID        pgtype.UUID
	RoomCode  string
	UserID    pgtype.UUID
	Score     float64
	CreatedBy string
	UpdatedBy string
	IsDeleted bool
}

// ------------------------------------- leaderboard ------------------------------------------------------------------------
func (q *Queries) CreatLeaderBoard(ctx context.Context, arg CreatLeaderBoardParams) error {
	_, err := q.db.Exec(ctx, creatLeaderBoard,
		arg.ID,
		arg.RoomCode,
		arg.UserID,
		arg.Score,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.IsDeleted,
	)
	return err
}

const createRoom = `-- name: CreateRoom :one
INSERT INTO room (
  id, 
  room_code,
  room_name, 
  room_owner, 
  room_chat, 
  room_meta, 
  room_lock, 
  is_active, 
  is_deleted, 
  created_on, 
  updated_on, 
  created_by, 
  updated_by,
  game_type,
  room_status
) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW(), NOW(), $10, $11, $12,$13)
RETURNING id, room_code, room_name, room_owner, room_chat, room_meta, room_lock, game_type, room_status, is_active, is_deleted, created_on, updated_on, created_by, updated_by
`

type CreateRoomParams struct {
	ID         pgtype.UUID
	RoomCode   string
	RoomName   pgtype.Text
	RoomOwner  pgtype.UUID
	RoomChat   []byte
	RoomMeta   []byte
	RoomLock   bool
	IsActive   bool
	IsDeleted  bool
	CreatedBy  string
	UpdatedBy  string
	GameType   string
	RoomStatus string
}

// --------------------------------- room table ---------------------------------------------------------------------
func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (Room, error) {
	row := q.db.QueryRow(ctx, createRoom,
		arg.ID,
		arg.RoomCode,
		arg.RoomName,
		arg.RoomOwner,
		arg.RoomChat,
		arg.RoomMeta,
		arg.RoomLock,
		arg.IsActive,
		arg.IsDeleted,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.GameType,
		arg.RoomStatus,
	)
	var i Room
	err := row.Scan(
		&i.ID,
		&i.RoomCode,
		&i.RoomName,
		&i.RoomOwner,
		&i.RoomChat,
		&i.RoomMeta,
		&i.RoomLock,
		&i.GameType,
		&i.RoomStatus,
		&i.IsActive,
		&i.IsDeleted,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const createRoomMember = `-- name: CreateRoomMember :one

INSERT INTO room_member (
  id, 
  room_code,
  room_id,
  user_id, 
  is_bot, 
  joined_on, 
  room_member_status, 
  is_active, 
  is_deleted, 
  created_on, 
  updated_on, 
  created_by, 
  updated_by    
)   
VALUES ($1, $2,$10, $3, $4, NOW(), $5, $6, $7, NOW(), NOW(), $8, $9)
RETURNING id, room_code, room_id, user_id, is_bot, joined_on, room_member_status, is_active, is_deleted, created_on, updated_on, created_by, updated_by
`

type CreateRoomMemberParams struct {
	ID               pgtype.UUID
	RoomCode         string
	UserID           pgtype.UUID
	IsBot            bool
	RoomMemberStatus string
	IsActive         bool
	IsDeleted        bool
	CreatedBy        string
	UpdatedBy        string
	RoomID           string
}

// ------------------------------------ Room Member ------------------------------------------------------------------------
func (q *Queries) CreateRoomMember(ctx context.Context, arg CreateRoomMemberParams) (RoomMember, error) {
	row := q.db.QueryRow(ctx, createRoomMember,
		arg.ID,
		arg.RoomCode,
		arg.UserID,
		arg.IsBot,
		arg.RoomMemberStatus,
		arg.IsActive,
		arg.IsDeleted,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.RoomID,
	)
	var i RoomMember
	err := row.Scan(
		&i.ID,
		&i.RoomCode,
		&i.RoomID,
		&i.UserID,
		&i.IsBot,
		&i.JoinedOn,
		&i.RoomMemberStatus,
		&i.IsActive,
		&i.IsDeleted,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getLeaderBoardByID = `-- name: GetLeaderBoardByID :many
SELECT id, room_code, user_id, score, created_on, updated_on, created_by, updated_by, is_deleted FROM leaderboard
WHERE id = $1 AND is_deleted = false
`

func (q *Queries) GetLeaderBoardByID(ctx context.Context, id pgtype.UUID) ([]Leaderboard, error) {
	rows, err := q.db.Query(ctx, getLeaderBoardByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Leaderboard
	for rows.Next() {
		var i Leaderboard
		if err := rows.Scan(
			&i.ID,
			&i.RoomCode,
			&i.UserID,
			&i.Score,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomByID = `-- name: GetRoomByID :many
SELECT id, room_code, room_name, room_owner, room_chat, room_meta, room_lock, game_type, room_status, is_active, is_deleted, created_on, updated_on, created_by, updated_by FROM room
WHERE id = $1 AND is_deleted = false
`

func (q *Queries) GetRoomByID(ctx context.Context, id pgtype.UUID) ([]Room, error) {
	rows, err := q.db.Query(ctx, getRoomByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Room
	for rows.Next() {
		var i Room
		if err := rows.Scan(
			&i.ID,
			&i.RoomCode,
			&i.RoomName,
			&i.RoomOwner,
			&i.RoomChat,
			&i.RoomMeta,
			&i.RoomLock,
			&i.GameType,
			&i.RoomStatus,
			&i.IsActive,
			&i.IsDeleted,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomByRoomCode = `-- name: GetRoomByRoomCode :many
SELECT id, room_code, room_name, room_owner, room_chat, room_meta, room_lock, game_type, room_status, is_active, is_deleted, created_on, updated_on, created_by, updated_by FROM room
WHERE room_code = $1 AND is_deleted = false
`

func (q *Queries) GetRoomByRoomCode(ctx context.Context, roomCode string) ([]Room, error) {
	rows, err := q.db.Query(ctx, getRoomByRoomCode, roomCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Room
	for rows.Next() {
		var i Room
		if err := rows.Scan(
			&i.ID,
			&i.RoomCode,
			&i.RoomName,
			&i.RoomOwner,
			&i.RoomChat,
			&i.RoomMeta,
			&i.RoomLock,
			&i.GameType,
			&i.RoomStatus,
			&i.IsActive,
			&i.IsDeleted,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomMemberByID = `-- name: GetRoomMemberByID :many
SELECT room_member.id, room_code, room_id, user_id, is_bot, joined_on, room_member_status, room_member.is_active, room_member.is_deleted, room_member.created_on, room_member.updated_on, room_member.created_by, room_member.updated_by, users.id, username, refresh_token, user_type, bot_type, user_meta, premium, users.is_active, users.is_deleted, users.created_on, users.updated_on, users.created_by, users.updated_by FROM room_member INNER JOIN users ON room_member.user_id = users.id
WHERE room_member.id = $1 AND room_member.is_deleted = false
`

type GetRoomMemberByIDRow struct {
	ID               pgtype.UUID
	RoomCode         string
	RoomID           string
	UserID           pgtype.UUID
	IsBot            bool
	JoinedOn         pgtype.Timestamp
	RoomMemberStatus string
	IsActive         bool
	IsDeleted        bool
	CreatedOn        pgtype.Timestamp
	UpdatedOn        pgtype.Timestamp
	CreatedBy        string
	UpdatedBy        string
	ID_2             pgtype.UUID
	Username         string
	RefreshToken     string
	UserType         string
	BotType          pgtype.Text
	UserMeta         []byte
	Premium          bool
	IsActive_2       bool
	IsDeleted_2      bool
	CreatedOn_2      pgtype.Timestamp
	UpdatedOn_2      pgtype.Timestamp
	CreatedBy_2      string
	UpdatedBy_2      string
}

func (q *Queries) GetRoomMemberByID(ctx context.Context, id pgtype.UUID) ([]GetRoomMemberByIDRow, error) {
	rows, err := q.db.Query(ctx, getRoomMemberByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoomMemberByIDRow
	for rows.Next() {
		var i GetRoomMemberByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.RoomCode,
			&i.RoomID,
			&i.UserID,
			&i.IsBot,
			&i.JoinedOn,
			&i.RoomMemberStatus,
			&i.IsActive,
			&i.IsDeleted,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.ID_2,
			&i.Username,
			&i.RefreshToken,
			&i.UserType,
			&i.BotType,
			&i.UserMeta,
			&i.Premium,
			&i.IsActive_2,
			&i.IsDeleted_2,
			&i.CreatedOn_2,
			&i.UpdatedOn_2,
			&i.CreatedBy_2,
			&i.UpdatedBy_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomMemberByRoomCodeAndUserID = `-- name: GetRoomMemberByRoomCodeAndUserID :many
SELECT room_member.id, room_code, room_id, user_id, is_bot, joined_on, room_member_status, room_member.is_active, room_member.is_deleted, room_member.created_on, room_member.updated_on, room_member.created_by, room_member.updated_by, users.id, username, refresh_token, user_type, bot_type, user_meta, premium, users.is_active, users.is_deleted, users.created_on, users.updated_on, users.created_by, users.updated_by FROM room_member INNER JOIN users ON room_member.user_id = users.id
WHERE room_code = $1 AND user_id = $2 AND room_member.is_deleted = false
`

type GetRoomMemberByRoomCodeAndUserIDParams struct {
	RoomCode string
	UserID   pgtype.UUID
}

type GetRoomMemberByRoomCodeAndUserIDRow struct {
	ID               pgtype.UUID
	RoomCode         string
	RoomID           string
	UserID           pgtype.UUID
	IsBot            bool
	JoinedOn         pgtype.Timestamp
	RoomMemberStatus string
	IsActive         bool
	IsDeleted        bool
	CreatedOn        pgtype.Timestamp
	UpdatedOn        pgtype.Timestamp
	CreatedBy        string
	UpdatedBy        string
	ID_2             pgtype.UUID
	Username         string
	RefreshToken     string
	UserType         string
	BotType          pgtype.Text
	UserMeta         []byte
	Premium          bool
	IsActive_2       bool
	IsDeleted_2      bool
	CreatedOn_2      pgtype.Timestamp
	UpdatedOn_2      pgtype.Timestamp
	CreatedBy_2      string
	UpdatedBy_2      string
}

func (q *Queries) GetRoomMemberByRoomCodeAndUserID(ctx context.Context, arg GetRoomMemberByRoomCodeAndUserIDParams) ([]GetRoomMemberByRoomCodeAndUserIDRow, error) {
	rows, err := q.db.Query(ctx, getRoomMemberByRoomCodeAndUserID, arg.RoomCode, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoomMemberByRoomCodeAndUserIDRow
	for rows.Next() {
		var i GetRoomMemberByRoomCodeAndUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.RoomCode,
			&i.RoomID,
			&i.UserID,
			&i.IsBot,
			&i.JoinedOn,
			&i.RoomMemberStatus,
			&i.IsActive,
			&i.IsDeleted,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.ID_2,
			&i.Username,
			&i.RefreshToken,
			&i.UserType,
			&i.BotType,
			&i.UserMeta,
			&i.Premium,
			&i.IsActive_2,
			&i.IsDeleted_2,
			&i.CreatedOn_2,
			&i.UpdatedOn_2,
			&i.CreatedBy_2,
			&i.UpdatedBy_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeaderBoardByRoomCode = `-- name: ListLeaderBoardByRoomCode :many
SELECT id, room_code, user_id, score, created_on, updated_on, created_by, updated_by, is_deleted FROM leaderboard
WHERE room_code = $1 AND is_deleted = false 
ORDER BY score DESC
`

func (q *Queries) ListLeaderBoardByRoomCode(ctx context.Context, roomCode string) ([]Leaderboard, error) {
	rows, err := q.db.Query(ctx, listLeaderBoardByRoomCode, roomCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Leaderboard
	for rows.Next() {
		var i Leaderboard
		if err := rows.Scan(
			&i.ID,
			&i.RoomCode,
			&i.UserID,
			&i.Score,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoomByUserID = `-- name: ListRoomByUserID :many
SELECT id, room_code, room_name, room_owner, room_chat, room_meta, room_lock, game_type, room_status, is_active, is_deleted, created_on, updated_on, created_by, updated_by FROM room
WHERE room_owner = $1 AND is_deleted = false
`

func (q *Queries) ListRoomByUserID(ctx context.Context, roomOwner pgtype.UUID) ([]Room, error) {
	rows, err := q.db.Query(ctx, listRoomByUserID, roomOwner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Room
	for rows.Next() {
		var i Room
		if err := rows.Scan(
			&i.ID,
			&i.RoomCode,
			&i.RoomName,
			&i.RoomOwner,
			&i.RoomChat,
			&i.RoomMeta,
			&i.RoomLock,
			&i.GameType,
			&i.RoomStatus,
			&i.IsActive,
			&i.IsDeleted,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoomMembersByRoomCode = `-- name: ListRoomMembersByRoomCode :many
SELECT room_member.id, room_code, room_id, user_id, is_bot, joined_on, room_member_status, room_member.is_active, room_member.is_deleted, room_member.created_on, room_member.updated_on, room_member.created_by, room_member.updated_by, users.id, username, refresh_token, user_type, bot_type, user_meta, premium, users.is_active, users.is_deleted, users.created_on, users.updated_on, users.created_by, users.updated_by FROM room_member INNER JOIN users ON room_member.user_id = users.id
WHERE room_code = $1 AND room_member.is_deleted = false
`

type ListRoomMembersByRoomCodeRow struct {
	ID               pgtype.UUID
	RoomCode         string
	RoomID           string
	UserID           pgtype.UUID
	IsBot            bool
	JoinedOn         pgtype.Timestamp
	RoomMemberStatus string
	IsActive         bool
	IsDeleted        bool
	CreatedOn        pgtype.Timestamp
	UpdatedOn        pgtype.Timestamp
	CreatedBy        string
	UpdatedBy        string
	ID_2             pgtype.UUID
	Username         string
	RefreshToken     string
	UserType         string
	BotType          pgtype.Text
	UserMeta         []byte
	Premium          bool
	IsActive_2       bool
	IsDeleted_2      bool
	CreatedOn_2      pgtype.Timestamp
	UpdatedOn_2      pgtype.Timestamp
	CreatedBy_2      string
	UpdatedBy_2      string
}

func (q *Queries) ListRoomMembersByRoomCode(ctx context.Context, roomCode string) ([]ListRoomMembersByRoomCodeRow, error) {
	rows, err := q.db.Query(ctx, listRoomMembersByRoomCode, roomCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRoomMembersByRoomCodeRow
	for rows.Next() {
		var i ListRoomMembersByRoomCodeRow
		if err := rows.Scan(
			&i.ID,
			&i.RoomCode,
			&i.RoomID,
			&i.UserID,
			&i.IsBot,
			&i.JoinedOn,
			&i.RoomMemberStatus,
			&i.IsActive,
			&i.IsDeleted,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.ID_2,
			&i.Username,
			&i.RefreshToken,
			&i.UserType,
			&i.BotType,
			&i.UserMeta,
			&i.Premium,
			&i.IsActive_2,
			&i.IsDeleted_2,
			&i.CreatedOn_2,
			&i.UpdatedOn_2,
			&i.CreatedBy_2,
			&i.UpdatedBy_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLeaderBoardScoreByID = `-- name: UpdateLeaderBoardScoreByID :exec
UPDATE leaderboard
SET 
  score = $2,
  updated_on = NOW(),
  updated_by = $3
WHERE id = $1 AND is_deleted = false
`

type UpdateLeaderBoardScoreByIDParams struct {
	ID        pgtype.UUID
	Score     float64
	UpdatedBy string
}

func (q *Queries) UpdateLeaderBoardScoreByID(ctx context.Context, arg UpdateLeaderBoardScoreByIDParams) error {
	_, err := q.db.Exec(ctx, updateLeaderBoardScoreByID, arg.ID, arg.Score, arg.UpdatedBy)
	return err
}

const updateLeaderBoardScoreByUserIDAndRoomCode = `-- name: UpdateLeaderBoardScoreByUserIDAndRoomCode :exec
UPDATE leaderboard
SET 
  score = $3,
  updated_on = NOW(),
  updated_by = $4
WHERE room_code = $1 AND user_id = $2 AND is_deleted = false
`

type UpdateLeaderBoardScoreByUserIDAndRoomCodeParams struct {
	RoomCode  string
	UserID    pgtype.UUID
	Score     float64
	UpdatedBy string
}

func (q *Queries) UpdateLeaderBoardScoreByUserIDAndRoomCode(ctx context.Context, arg UpdateLeaderBoardScoreByUserIDAndRoomCodeParams) error {
	_, err := q.db.Exec(ctx, updateLeaderBoardScoreByUserIDAndRoomCode,
		arg.RoomCode,
		arg.UserID,
		arg.Score,
		arg.UpdatedBy,
	)
	return err
}

const updateRoomByID = `-- name: UpdateRoomByID :exec
UPDATE room
SET 
  room_name = $2,
  room_chat = $3,
  room_meta = $4,
  room_lock = $5,
  is_active = $6,
  updated_on = NOW(),
  updated_by = $7,
  game_type = $8,
  room_status = $9
WHERE id = $1
`

type UpdateRoomByIDParams struct {
	ID         pgtype.UUID
	RoomName   pgtype.Text
	RoomChat   []byte
	RoomMeta   []byte
	RoomLock   bool
	IsActive   bool
	UpdatedBy  string
	GameType   string
	RoomStatus string
}

func (q *Queries) UpdateRoomByID(ctx context.Context, arg UpdateRoomByIDParams) error {
	_, err := q.db.Exec(ctx, updateRoomByID,
		arg.ID,
		arg.RoomName,
		arg.RoomChat,
		arg.RoomMeta,
		arg.RoomLock,
		arg.IsActive,
		arg.UpdatedBy,
		arg.GameType,
		arg.RoomStatus,
	)
	return err
}

const updateRoomMemberByID = `-- name: UpdateRoomMemberByID :exec
UPDATE room_member
SET 
  room_member_status = $2,
  is_active = $3,
  updated_on = NOW(),
  updated_by = $4
WHERE id = $1
`

type UpdateRoomMemberByIDParams struct {
	ID               pgtype.UUID
	RoomMemberStatus string
	IsActive         bool
	UpdatedBy        string
}

func (q *Queries) UpdateRoomMemberByID(ctx context.Context, arg UpdateRoomMemberByIDParams) error {
	_, err := q.db.Exec(ctx, updateRoomMemberByID,
		arg.ID,
		arg.RoomMemberStatus,
		arg.IsActive,
		arg.UpdatedBy,
	)
	return err
}

const updateRoomMemberByRoomCodeAndUserID = `-- name: UpdateRoomMemberByRoomCodeAndUserID :exec
UPDATE room_member
SET 
  room_member_status = $2,
  is_active = $3,
  updated_on = NOW(),
  updated_by = $4
WHERE room_code = $1 AND user_id = $5 AND is_deleted=false
`

type UpdateRoomMemberByRoomCodeAndUserIDParams struct {
	RoomCode         string
	RoomMemberStatus string
	IsActive         bool
	UpdatedBy        string
	UserID           pgtype.UUID
}

func (q *Queries) UpdateRoomMemberByRoomCodeAndUserID(ctx context.Context, arg UpdateRoomMemberByRoomCodeAndUserIDParams) error {
	_, err := q.db.Exec(ctx, updateRoomMemberByRoomCodeAndUserID,
		arg.RoomCode,
		arg.RoomMemberStatus,
		arg.IsActive,
		arg.UpdatedBy,
		arg.UserID,
	)
	return err
}

const updateRoomMetaByRoomCode = `-- name: UpdateRoomMetaByRoomCode :exec
UPDATE room
SET 
  room_meta = $2,
  updated_on = NOW(),
  updated_by = $3
WHERE room_code = $1 AND is_deleted = false
`

type UpdateRoomMetaByRoomCodeParams struct {
	RoomCode  string
	RoomMeta  []byte
	UpdatedBy string
}

func (q *Queries) UpdateRoomMetaByRoomCode(ctx context.Context, arg UpdateRoomMetaByRoomCodeParams) error {
	_, err := q.db.Exec(ctx, updateRoomMetaByRoomCode, arg.RoomCode, arg.RoomMeta, arg.UpdatedBy)
	return err
}
