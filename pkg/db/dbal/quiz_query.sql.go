// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: quiz_query.sql

package dbal

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAnswer = `-- name: CreateAnswer :exec

INSERT INTO answer (id,
    room_code,
    user_id,
    question_id,
    question_data_id,
    answer_option,
    is_correct,
    answer_time,
    created_by,
    updated_by,
    created_on,
    updated_on)
VALUES ($10,$1, $2, $3, $4, $5, $6, $7, $8, $9, NOW(), NOW())
`

type CreateAnswerParams struct {
	RoomCode       string
	UserID         pgtype.UUID
	QuestionID     pgtype.UUID
	QuestionDataID pgtype.UUID
	AnswerOption   int32
	IsCorrect      bool
	AnswerTime     pgtype.Timestamp
	CreatedBy      string
	UpdatedBy      string
	ID             pgtype.UUID
}

// -------------------------- answers --------------------------------------
func (q *Queries) CreateAnswer(ctx context.Context, arg CreateAnswerParams) error {
	_, err := q.db.Exec(ctx, createAnswer,
		arg.RoomCode,
		arg.UserID,
		arg.QuestionID,
		arg.QuestionDataID,
		arg.AnswerOption,
		arg.IsCorrect,
		arg.AnswerTime,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.ID,
	)
	return err
}

const createQuestion = `-- name: CreateQuestion :exec
INSERT INTO question (id,
    room_code,
    topic,
    question_count,
    question_data,
    time_limit,
    created_by,
    updated_by, 
    created_on, 
    updated_on)
VALUES ($7,$1, $2, $3, $4, $5,$6, $8,NOW(), NOW())
`

type CreateQuestionParams struct {
	RoomCode      string
	Topic         pgtype.Text
	QuestionCount int32
	QuestionData  []byte
	TimeLimit     int32
	CreatedBy     string
	ID            pgtype.UUID
	UpdatedBy     string
}

// --------------------------- questions --------------------------------
func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) error {
	_, err := q.db.Exec(ctx, createQuestion,
		arg.RoomCode,
		arg.Topic,
		arg.QuestionCount,
		arg.QuestionData,
		arg.TimeLimit,
		arg.CreatedBy,
		arg.ID,
		arg.UpdatedBy,
	)
	return err
}

const getAnswerByRoomCodeAndUserID = `-- name: GetAnswerByRoomCodeAndUserID :many
SELECT id, room_code, user_id, question_id, question_data_id, answer_option, is_correct, answer_time, created_on, updated_on, created_by, updated_by
FROM answer
WHERE room_code = $1
AND user_id = $2
`

type GetAnswerByRoomCodeAndUserIDParams struct {
	RoomCode string
	UserID   pgtype.UUID
}

func (q *Queries) GetAnswerByRoomCodeAndUserID(ctx context.Context, arg GetAnswerByRoomCodeAndUserIDParams) ([]Answer, error) {
	rows, err := q.db.Query(ctx, getAnswerByRoomCodeAndUserID, arg.RoomCode, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Answer
	for rows.Next() {
		var i Answer
		if err := rows.Scan(
			&i.ID,
			&i.RoomCode,
			&i.UserID,
			&i.QuestionID,
			&i.QuestionDataID,
			&i.AnswerOption,
			&i.IsCorrect,
			&i.AnswerTime,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionsByRoomCode = `-- name: GetQuestionsByRoomCode :one
SELECT id, room_code, topic, question_count, question_data, time_limit, created_on, updated_on, created_by, updated_by
FROM question
WHERE room_code = $1
ORDER BY created_on ASC
`

func (q *Queries) GetQuestionsByRoomCode(ctx context.Context, roomCode string) (Question, error) {
	row := q.db.QueryRow(ctx, getQuestionsByRoomCode, roomCode)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.RoomCode,
		&i.Topic,
		&i.QuestionCount,
		&i.QuestionData,
		&i.TimeLimit,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const listAnswersByRoomCode = `-- name: ListAnswersByRoomCode :many
SELECT id, room_code, user_id, question_id, question_data_id, answer_option, is_correct, answer_time, created_on, updated_on, created_by, updated_by
FROM answer
WHERE room_code = $1
ORDER BY created_on ASC
`

func (q *Queries) ListAnswersByRoomCode(ctx context.Context, roomCode string) ([]Answer, error) {
	rows, err := q.db.Query(ctx, listAnswersByRoomCode, roomCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Answer
	for rows.Next() {
		var i Answer
		if err := rows.Scan(
			&i.ID,
			&i.RoomCode,
			&i.UserID,
			&i.QuestionID,
			&i.QuestionDataID,
			&i.AnswerOption,
			&i.IsCorrect,
			&i.AnswerTime,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAnswer = `-- name: UpdateAnswer :exec
UPDATE answer
SET answer_option = $2,
    is_correct = $3,
    answer_time = $4,
    updated_on = NOW(),
    updated_by = $5
WHERE id = $1
`

type UpdateAnswerParams struct {
	ID           pgtype.UUID
	AnswerOption int32
	IsCorrect    bool
	AnswerTime   pgtype.Timestamp
	UpdatedBy    string
}

func (q *Queries) UpdateAnswer(ctx context.Context, arg UpdateAnswerParams) error {
	_, err := q.db.Exec(ctx, updateAnswer,
		arg.ID,
		arg.AnswerOption,
		arg.IsCorrect,
		arg.AnswerTime,
		arg.UpdatedBy,
	)
	return err
}

const updateQuestionByID = `-- name: UpdateQuestionByID :exec
UPDATE question
SET 
  topic = $2,
  question_count=$5,
  question_data = $3, 
  time_limit = $6,
  updated_on = NOW(),
  updated_by = $4
WHERE id = $1
`

type UpdateQuestionByIDParams struct {
	ID            pgtype.UUID
	Topic         pgtype.Text
	QuestionData  []byte
	UpdatedBy     string
	QuestionCount int32
	TimeLimit     int32
}

func (q *Queries) UpdateQuestionByID(ctx context.Context, arg UpdateQuestionByIDParams) error {
	_, err := q.db.Exec(ctx, updateQuestionByID,
		arg.ID,
		arg.Topic,
		arg.QuestionData,
		arg.UpdatedBy,
		arg.QuestionCount,
		arg.TimeLimit,
	)
	return err
}
